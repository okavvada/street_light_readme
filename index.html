<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Street Light Project by okavvada</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">


  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Paris Street Light Project</h1>
        <p class="header"></p>

        <p class="header">Spatial Analysis</p>

      </header>
      <section>

        <h3>
<c class="anchor" aria-hidden="true"></c>Original Data</h3>
<p><u>Open Data: </u>
<ul>- Road geometries: troncon voie</ul>
<ul>- Street lights: eclairage public</ul>

<u>Street Light Data: </u>
<ul>- MS Access Database: MuseEvesa_ExportVDP_Engie_v8.mdb</ul>
<ul>    (geometry: SPATIALPOINT)</ul>

<u>Measurement Data: </u>
<ul>- xls files: Campagne 2018 Paris</ul>
<ul>- raw measurement data: brute</ul>
<ul>- analysis data: analyse</ul></p>


<h3><c class="anchor" aria-hidden="true"></c>Road Geometric Calculations</h3>
<span class="subheader">Add Road/Sidewalk Widths to road geometries</span>
<p><span class="number-item">1. Calculate polygon widths:</span> We use the polygon features for roadways and sidewalks, sourced by the City of Paris open data. The steps to add road and sidewalk widths are as follow:
<ul>- First we calculate the area of all the polygons (roads and sidewalks) in square meters.</ul>
<ul>- Then we approximate the length of each polygon by calculating the longest line in the shape. </ul>
<ul>- The width of the polygon is then identified by dividing the area with the length. </ul></p>

<p><span class="number-item">2. Connect polygons to line geometries:</span> The next step is to connect the roads ids, with the polygon features in order to get a 1-to-1 connection between all polygons to a road segment. That will help us connect the calculated widths to a the street line geometry.</p>

<ul>- First we convert the roads line geometry to a centroid so we can match the polygons.</ul>
<ul>- For each polygon we then identify the closest centroid and match it to it. As an optimization for faster spatial operations we only search for the closest point inside a buffer zone of 100m</ul>
<ul>- We create look up tables with road ids and road polygon and sidewalk ids for each. As one road can have multiple sidewalks the lookup table can have multiple sidewalk ids for the same road id</ul>
<ul>- We join the polygon tables with the road id using the lookup tables and assign an area and a width to each road segment. If there are multiple sidewalks assigned to a road segment, the sum of the width and area are added.</ul>

<span class='map'><iframe src="maps/road_widths.html" height="600" width="1000"></iframe></span>

<h3>
<c class="anchor" aria-hidden="true"></c>Lighting Preprocessing</h3>

<p><span class="number-item">1. Preprocessing: </span>Fistly, some preprocessing was done to convert the point geometries to WGS 84 and delete some geometries that were not assigned with the correct SRID and could not be projected.
All relevant tables from the MS access database were then joined into one using the IDs provided and explained in the Metadata.xls file. This data was stored in a new table called "all_mdb_data".</p>
<p><span class="number-item">2. Filtering: </span>The data was filtered to only include lighting features and this new data was stored in a new table called "street_lights_only" by "MTYLIBELLE" = 'Lampe EP'.</p>
<p><span class="number-item">3. Spatial join: </span>Then the street light geometries where connected with the open data street light geometries by distance. For optimization reasons only the lights that were in close proximity (within 10 m of each other) were assessed when looking for the closest one. To avoid duplicate lights being assigned to a single point, all street lights were only allowed to have one connection with a different point. The lookup table with the codes for the connection was stored in a new table called "open_mdb_lights_codes". Using the lookup table the street lights were connected to the open data street lights and their properties shared. The joined tables were stored as a new table "open_mdb_lights".</p>

<h3>
<c class="anchor" aria-hidden="true"></c>Lighting Measurements</h3>

<span class="subheader">Connecting measurements to road segments</span>
<p>The light measurements are sourced from the xls files from the client. The xls files are combined into one file before they are uploaded to Postgres. The "brute" file is the raw measurements and the "analyse" file is the analyses for each road segment. We will use the brute file to connect the road names to the road segment ids, and the analyse file to assign the result of the street light measurements to each road segment.</p>
<p><span class="number-item">1. Unique ID: </span>First we generate a new column for both the brute and analyse files that will concatenate the CONTRAT, VOIE and TRONCON into one field, so each road segment has a unique identifier and re-upload to the database.</p>
<p><span class="number-item">2. Spatial join: </span>Similar as before we connect each measurement to its closest road segment by distance. We group by all the road segments, and each gets the most popular name out of all the measurement points that were connected to it. That is to avoid mismatches in street corners, where the measurement might be closer to a different road segment. The result is added to a lookup table named "roadName_rid_codes".</p>
<p><span class="number-item">3. Additional names: </span>We can also add the data from the lookup table that was generated before that includes the road names from the street light data ("roadName_fromlights_rid").</p>
<p><span class="number-item">4. Join to roads: </span>Finally, we join the analyse table with the road segment geometries using the lookup table that was just generated.</p></p>

<h3>
<c class="anchor" aria-hidden="true"></c>Lighting Infrastructure</h3>

<span class="subheader">Connecting lights to road segments</span>
<p><span class="number-item">1. Road names: </span>
The street lights are then connected to the road segments by distance to create a lookup table between the road names as present in the street light table (VOILIBELLE) and the road id. Each light is connected to one road and then the road id is assigned the most popular name from all street lights connected to it. That is done to avoid wrong naming streets as some lights on corners are assigned to them but technically belong to a different street. If a road was connected to lights with different road names associated with them (same number of lights in each group), then the road took the name of one of the groups and the rest of the lights would be unconnected. To enhance the process of connecting lights to roads, the same process was run again using as inputs the street lights and road segments that were left unmatched on the first round. This optimization enabled more lights to be connected to roads, and more roads to be given names. </p>
<p><span class="number-item">2. Count street lights on road: </span>Then each street light is assigned to a road segment by distance. As mentioned before some street lights on corners might be closer to a different segment. To avoid mismatching only the roads that have the same name as the one mentioned in the street lights table as assessed when looking for the closest segment. 
Finally, for each road segment the lights that were matched to it are counted and added as a separate column in the streets table "stlights_number".</p>

<span class='map'><iframe src="maps/street_lights2.html" height="600" width="1000"></iframe></span>

<p><span class="number-item">3. Estimating power consumption per road segment: </span>The dataset for street lights from the open dataset has 2 relevant fields for actual lamp power PWE using an electronic driver and PWC using a condensator "balast". For each road segments, these two fields were summed for all the lights that were assigned to it and the final power consumption of the segment was added as a field to the road under the column "pwe_pwc". </p>

<p><span class="number-item">4. Identify lamp type: </span>The dataset for street lights given by the client has a lamp description field under MTFLIBELLE. For each description a short code name to describe the lamp type was associated with each street light as:
<li>Lampe ballon fluorescent, Lampe fluo compact, Tube fluorescent = FLUO</li>
<li>Lampe sodium basse pression = SBP</li>
<li>Lampe sodium haute pression substituÃ©e, Lampe sodium haute pression existante, Lampe sodium trÃ¨s haute pression = SHP</li>
<li>Lampe Cosmopolis, Lampe Ã\xa0 iodures mÃ©talliques = IM</li>
<li>Diodes Electroluminescentes, Source Panneau Lumineux = LED</li>

Also, the lights that were inside a park identified from the PROLIBELLE = DEVE field in the database were assigned the code '_DEVE' in the end of their lamp type</p>

<p><span class="number-item">5. Identify lamp type priority: </span>Based on their lamp type, priorities were defined as:
<li>FLUO = 1</li>
<li>SBP = 5</li>
<li>SHP = 8</li>
<li>LED = 10</li>
<li>if inside a park (DEVE) but not LED = 3</li>
</p>


<h3>
<c class="anchor" aria-hidden="true"></c>Road segment lighting types</h3>
<p><span class="number-item">1. Primary and Secondary light types for each segment: </span>To identify what the primary light type of each road segment a number of rules were followed.
<li>If there was only one lamp type listed as 'Luminaire fonctionnel' then that was the primary one. Else,</li>
<li>the light type with maximum height was set us primary</li>
<li>If there was only one lamp type listed as 'Luminaire espace pietons' then that was the secondary one. Else,</li>
<li>if there was only one lamp type with height in between 0.5 and 3 m that one was set as the secondary one. Else,</li>
<li>the most populous lamp type was set as the secondary one.</li></p>

<p><span class="number-item">2. Energy savings for each segment: </span>For each road segment the energy savings were calculated if the lamp type was converted into an LED. Firstly, the power of the road segment with an LED light was estimated using the LED efficiency of 0.06 W/m2*lux, the road and sidewalk area (estimated before) and the mean existing lighting level listed in the measurement database (Eclairement_moyen_exige). This was divided by the number of street lights per segment to get an average required power. The energy savings are calculated by subtracting the actual power estimated above (pwe_pwc) from the LED power.</p>

<p><span class="number-item">3. Road segment conformity priority: </span>The priorities for each road segment were set as described in the image below.</p>

<img src="maps/troncon_priority.png">

<p><span class="number-item">4. Entire road conformity priority: </span>For the entire road that corresponds to multiple road segments the priorities were set if a certain amount of road segments were fullfilling certain criteria as specified below.</p>

<img src="maps/rue_priority.png">

<h3>
<c class="anchor" aria-hidden="true"></c>Parks and Biodiversity</h3>
<p>This assessment aims to direct to street lights that have an influence on parks.</p>
<p><span class="number-item">1. Lights inside parks: </span>To identify which street lights fall within the boundaries of parks with enclosures, the `PROLIBELLE` field was used and checked whether `DEVE` was contained in the field attributes. In addition, the field `NRELIBELLE = HORAIRE EP` and  `NRELIBELLE = HORAIRE SQUARE` were used.  
The parks with enclosures were selected by using the field `presence_cloture = oui` and the lights that intersect with those parks were selected.</p>
<p><span class="number-item">2. Lights close to parks: </span>To identify which street lights are located close to parks, a buffer of 40 m was included in the park dataset and the street lights that fall into it were selected as having a proximity to the parks. A column was added to the lights table with the id of the park that they were close to `park_ogc_fid`. Their distance to the park was also calculated in meters and added as a separate column `dist_to_park`. </p>
<p><span class="number-item">3. Building shadows: </span>As an advanced feature of the lights that have a proximity to parks, we wanted to exclude the street lights that are close to parks but a building is intejecting the direct contact between light and park. To achieve this, we connected each light with its closest park with a line that connects the point of the line to the point along the park polygon that is closest to the light. Then we checked whether this line intersects any buildings. If not, the light and park remain connected `park_influence = yes` otherwise `park_influence = no`.</p>

<img src="maps/park_lights.png" height=300px>

<span class='map'><iframe src="maps/shadows.html" height="600" width="1000"></iframe></span>


<h3>
<c class="anchor" aria-hidden="true"></c>Energy consumption</h3>
<p>This assessment aims to calculate the current and future energy consumption for each road segment.</p>
<p><span class="number-item">1. Current and future power for each lamp type: </span> For each lamp type a current and future power value was estimated by INEO. These values were connected to the lighting database using the field `MBILIBELLE` and assigned to each light in the database. </p>
<p><span class="number-item">2. Current and future power for each road segment: </span> The lights were connected to the roads that they belong to by using the lookup table `stlights_on_road` developed previously and for each road segment the power * hours of operation (given in `NRSTOTAL`) was calculated for current and future energy use. </p>
<p><code>current_power_MWh = sum(mbipw * NRSTOTAL/1000) </code></p>
<p><code>future_power_MWh = sum(pwled * NRSTOTAL/1000) </code></p>


<h3>
<c class="anchor" aria-hidden="true"></c>EV charging</h3>
<p>This assessment aims to identify the lighting poles that could potentially be candidate locations for EV charging stations. The candidate locations need to be close to a parking spot (no more than 2m away) and have no buildings or other obstacles in between the parking spot and the pole.</p>
<p><span class="number-item">1. Identify poles: </span> The poles are identified from the lighting dataset by applying the filters `CandÃ©labre` or `MÃ¢t`.  </p>
<p><span class="number-item">2. Buffer: </span> A buffer zone of 2 m is applied to all parking spots (after they have been projected to a metric projection epsg:31467). The poles that fall within this buffer zone are selected. </p>
<p><span class="number-item">3. Calculate distance: </span> A distance is calculated from all the poles that fall within the 2 m buffer zone to the closest point of a parking spot. The distance is listed in the `dist_to_parking` field. </p>
<p><span class="number-item">3. Building interference: </span> As an advanced feature of the poles that have a proximity to parking spots, we wanted to exclude the poles that have a building  intejecting the direct contact between pole and parking. To achieve this, we connected each pole with its closest parking with a line that connects the point of the line to the point along the parking polygon that is closest to the pole. Then we checked whether this line intersects any buildings. If not, the pole and park remain connected and a property is set as `ev_charging = yes` otherwise `ev_charging = no`.</p>

<span class='map'><iframe src="maps/ev_charging.html" height="600" width="1000"></iframe></span>

</div>
		
  </body>
</html>

